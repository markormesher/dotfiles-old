#!/usr/bin/env bash
set -euo pipefail

if [ ! -z ${SET_X+x} ]; then
  set -x
fi

# sanity-check: is dotfiles in the right place?
if [ ! -d "${HOME}/dotfiles" ]; then
  echo "ERROR: ${HOME}/dotfiles does not exist"
  exit 1
fi

cd "${HOME}/dotfiles"
source ./bin/common-functions.sh

# replace sed if we're on Mac
sed="sed"
if command -v gsed > /dev/null; then
  sed="gsed"
fi

print_info "Clearing old sandbox directory"
mkdir -p .sandbox
rm -rf .sandbox/*

print_info "Setting up symlinks"
find "${HOME}/dotfiles" -iname "*.symlink" | while read -r file; do
  if ! file_matches_host_tags "${file}"; then
    continue
  fi

  link=$( ( ( grep " dot-link-to" || : ) | cut -d ' ' -f 3 | sed "s#{HOME}#${HOME}#g" ) < "${file}" )
  if [ -z "${link}" ]; then
    print_error "No 'dot-link-to' found for ${file}"
    exit 1
  fi

  sandbox_file="${HOME}/dotfiles/.sandbox/$( ( md5sum | cut -d ' ' -f 1 ) < "${file}" )"
  ( grep -v " dot-link-to " | grep -v " dot-tags " ) < "${file}" > "${sandbox_file}"

  rm "${link}" 2> /dev/null || :
  mkdir -p "$(dirname "${link}")"
  ln -s "${sandbox_file}" "${link}"
  print_debug "Linking ${link} -> ${sandbox_file}"
done

print_info "Adding source scripts to bootstrapper"
echo "" > .bootstrap
find "${HOME}/dotfiles" -iname "*.source" | sort | while read -r file; do
  if ! file_matches_host_tags "${file}"; then
    continue
  fi

  echo "source \"${file}\"" >> .bootstrap
  print_debug "Adding source for ${file}"
done

print_info "Setting up \$PATH"
new_path_list=$(mktemp)
find "${HOME}/dotfiles" -iname "*.path" | while read -r file; do
  if ! file_matches_host_tags "${file}"; then
    continue
  fi

  ( grep -v " dot-tags " ) < "${file}" >> "${new_path_list}"
  print_debug "Getting paths from ${file}"
done

# strip blank lines
$sed -i '/^\s*$/d' "${new_path_list}"

# replace HOME references
$sed -i "s#{HOME}#${HOME}#g" "${new_path_list}"

# sort lines (some are prefixed with numbers to give priority)
sort -o "${new_path_list}" "${new_path_list}"

# remove number prefixes
$sed -i -r 's/[0-9]+#//' "${new_path_list}"

# concat lines with : and set path
new_path=$( tr '\n' ':' < "${new_path_list}" )
echo "export PATH=${new_path}" >> .bootstrap
rm "${new_path_list}"

print_info "Setting up crontab"
new_crontab="$(mktemp)"
find "${HOME}/dotfiles" -iname "*.cron" | while read -r file; do
  if ! file_matches_host_tags "${file}"; then
    continue
  fi

  ( grep -v " dot-tags " | grep -v '^$' ) < "${file}" >> "${new_crontab}"
  print_debug "Adding cron from ${file}"
done
crontab "${new_crontab}"
rm "${new_crontab}"

print_info "Setting up public keys"
managed_keys="$(mktemp)"
find "${HOME}/dotfiles/pubkeys" -iname "*.rsa" | while read -r file; do
  if ! file_matches_host_tags "${file}"; then
    continue
  fi

  ( grep -v " dot-tags " | grep -v '^$' ) < "${file}" >> "${managed_keys}"
  print_debug "Adding public key from ${file}"
done

# set up the new file (without clobbering non-managed entries)
if [ ! -f "${HOME}/.ssh/authorized_keys" ]; then
  mkdir -p "${HOME}/.ssh"
  touch "${HOME}/.ssh/authorized_keys"
fi

new_authed_keys=$(mktemp)
if grep "managed by dotfiles" "${HOME}/.ssh/authorized_keys" > /dev/null; then
  # we've already modified this file so we need to remove dupes and trim our old content
  print_debug "authorized_keys has been touched before"
  trim_below_line=$(grep -n "managed by dotfiles" "${HOME}/.ssh/authorized_keys" | cut -d ':' -f 1 | head -n 1)
  head -n $(( trim_below_line - 1 )) "${HOME}/.ssh/authorized_keys" | (grep -v -F -f "${managed_keys}" || :) | rm_head_tail_blank_lines > "${new_authed_keys}"
else
  # we've not touched this file before so we only need to remove dupes
  print_debug "authorized_keys is new to us"
  cat "${HOME}/.ssh/authorized_keys" | (grep -v -F -f "${managed_keys}" || :) | rm_head_tail_blank_lines > "${new_authed_keys}"
fi

echo "" >> "${new_authed_keys}"
echo "# keys below managed by dotfiles" >> "${new_authed_keys}"
cat "${managed_keys}" >> "${new_authed_keys}"

cat "${new_authed_keys}" | rm_head_tail_blank_lines > "${HOME}/.ssh/authorized_keys"
rm "${managed_keys}" "${new_authed_keys}"
